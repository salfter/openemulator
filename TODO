==To-Do==
* Solve the problem of attempting to remove devices that can't be removed at the present time (e.g. power should be disconnected first) or never (e.g. core). Should a delegate in OEEmulation be used?
* Solve the problem of attempting to add a device that can't be added safely at the current time.
* Find a solution to the storage API problem. How is the mount state indicated? Should there be an additional EMULATION_SET_MOUNTED command?
* Implement the main emulation window list
* Implement addCanvas and removeCanvas -> this should create a windowController and an OEOpenGLCanvas. The window controller should be added to the document, and the canvas returned.
* Implement frame communication to the canvas
* Implement canvas keyboard entry/mouse events
* Implement mouse and keyboard capture
* Implement canvas window persistency
* Implement [Document updateChangeCount]
* Implement disk image drag and drop in canvas window
* Implement disk image drag and drop in emulation window

* Implement main emulation window mount/unmount
* Implement main emulation window reveal
* Enable main emulation window system keyboard actions, when a device has a canvas
* Implement OEEmulation addEDL
* Implement OEEmulation removeDevice
* Implement main emulation window add EDL
* Implement main emulation window remove device
* Implement hardware chooser

* Integrate OpenGL 2.0 shader
* Implement the option to deactivate shaders
* Implement the inspector
* Devise an interface to allow native OpenGL commands in emulations

==Future to-do's==
* Debugging with JTAG
* TCP AT Modem emulation
* Debugger commands: run/step/break/readRegister/writeRegister/readMemory/writeMemory/addTrap/removeTrap/listTraps

==Apple-1==
* DA: Data Available
* RDA: Ready Data Accept
* ~W = ~RDA | ~(~RDA | RD6 | RD7)
* W = RDA & (RD6 | RD7)

==Apple-1 Cassette Interface==
* ROM is visible at $C000-$C1FF
* $C000 to $C0FF generate a click
* $C080 to $C0FF puts A0 to 0, if a signal is detected
* A &= ~((A >> 7) & 1 | DET)
* O: if (DET) address &= ~1;

==Apple II==
* There should be an MMU flag to inhibit Apple II memory space
* Apple II INH is $D000-$FFFF, Apple IIe $0000-$FFFF, what should be Apple IIGS INH?
* An interface is capable of modifying this flag, in order to inhibit the MMU
* Video obtains main and aux memory from MMU
* aux memory registers in the MMU
* MMU responds to $C001-$C00F, $C011-$C01F, $C050-$C057, $C080-$C08F.
* Apple II video is capable of delegating $C050-$C057
* The language card uses memory offset
* Game port allows delegations
* Video: Rev.0 has 4 colores with no color killer, rev. 1 has 6 with ck 
* Apple III video resistors: 2k to SYNC, 2k to GND, 6.2k to X1 X2 X4 X8, 5.1k to NA NB
* Video chaining should be possible (for 80 column cards)
* Do this through video inhibition?



What follows is the compendium of old ideasÉ

==OpenEmulator==
* When application looses focus, all fullscreen windows should be de-zoomed
* Implement character palette (NSTextView?)
* Implement CPU Load
* When mounting, there should be two messages: one for asking if a disk image is recognized, and another if it can be mounted.
* Fix template chooser width problem, when scroll bars show and hide
* Fix template chooser problem when the first line of items is not selected
* When starting OpenEmulator, there should be a dialogue requesting confirmation that you are allowed to use the ROM files
* When re-mounting a mounted disk image, show an error

==Composite monitor ==
* Usually 92% of total image is visible

==Apple-1 Video==
Cursor frequency 1.924 Hz
Cursor duty cycle 66.6%
0.173 ms low (@ sign)
0.346 ms high (normal space)

==Apple II==
* Check if this is true: While resetting, the drives are turned off, but the 1s timer should not be disabled. When reset is over, drive 1 should still spin for the rest of the second
* Improve NIB sync detection (by looking for regularly spaced sync data)
* Fix Wasteland, Alkemstone, Crusader in Europe, Decision in the Desert, Decisive Battles of the World, Earth Orbit Stations, Europe Ablaze, Hacker's Challenge, Halls of Montezuma, The Last Gladiator, LBSCharDisk, MacArthur's War
* Fix Sherlock Forest

==Apple II Video==
* When writing video memory, video is updated til current CRT position
* When video mode is changed, video is updated til CRT position
* There should be something to change writeMemory as a function of video mode
* Apple IIGS speed changes should be emulated, according to the kind of memory access: normal @ 2.5 MHz, ROM @ 2.8 MHz, E0 and E1 @ 1.0 MHz.
* Should vertical NTSC color blurring (for Karateka) be emulated?
* Idea: use audio buffer size of 256 (187.5 Hz) or 512 (93.75 Hz) samples, so user does not experience A/V desync.
* Apple IIGS aspect ratio:
200mm x 150mm active video area
292mm diagonal (viewable): sqrt(x * x + x * x * 1.33 * 1.33) = x * sqrt(1 + 1.33^2)
233mm x 175mm
Video bandwidth: 1.5 dB at 6.5 MHz, 3 dB at 8 MHz

200 mm -> 532 pixels
233 mm -> 620 pixels

150 mm -> 400 pixels
175 mm -> 466 pixels

* Apple II:
** At the far left, the last video scanner dot is inserted
** At the far right, the last video scanner dot is always cut off
* Apple IIe HIRES:
** At the far left, black is always inserted
** At the far right, the last video dot thing is always cut off

===NTSC===
* Vertical blanking: 19 scanlines
* Visible: 243.5 scanlines
* Usually 240 scanlines are used

* Color carrier  = 3.579545 MHz
* Horizontal frequency = (2 / 455) * Color carrier
* Horizontal period H = 1 / (3579545 * 2 / 455) = 63.556µs

* Front porch: 1.5µs
* Horizontal sync: 4.7µs
* Breezeway: 0.6µs
* Color burst: 2.50µs
* Back porch: 1.6µs

* Visible: 52.6556µs

* 60 Hz	32 cycles before, 4 cycles VSYNC (33, 34, 35, 36), 34 later

===PAL===
* Vertical blanking: 25 scanlines
* Visible: 287.5 scanlines
* Usually 288 scanlines are used

* Horziontal period: 64µs

* Front porch: 1.5µs
* Horizontal sync: 4.7µs
* Breezeway: 0.9µs
* Color burst: 2.25µs
* Back porch: 2.65µs

* Visible nominal: 52µs

* 50 Hz	72 cycles before, 4 cycles VSYNC (73, 74, 75, 76), 44 later

==Apple II Timing==
OpenEmulator function prototypes:

* onEvent()
{
	while (clockIndex < clockEnd)
	{
		if (clockIndex >= clockNextScanline)
		{
			clockNextScanline += 912;// 64*14 + 16;
			clockIndex += clockScanlineInc;
			scanlineCallback();
		}
		clockIndex += clockCycleInc;
		cpuCallback();
	}
}

For Apple II: clockCycleInc = 14, clockScanlineInc = 2
For Apple IIGS: clockCycleInc = 5, clockScanlineInc = 0
For Z80: clockCycleInc = 7, clockScanlineInc = 2

* selectCPU()
* setCPU(Component *)
* setCPUSpeed(double speed, bool isLongCycle)
* delay(double clockCount)
* getHorizontalClock()
* getHorizontalCount()
* getVerticalCount()
* getQ3()
* double getTime()

==Apple IIGS Timing==
| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | 
F         R         F         F         F         F         F         F         F         F         F         R         F
S                           S                           S                           S                           S

Master clock: 14 MHz (70ns)
Fast clock: 2.857 MHz
Slot clock: 1.020 MHz
1 out of every 10 fast clocks is refresh (thus the next is used up)

* Master clock: 70 ns = 14 MHz (!)
* Fast Apple IIGS cycle: 350 ns = 2.857142 MHz
* RAM Apple IIGS cycle: 700 ns = 1.428571 MHz
* Isolated Apple II cycle: 1330 ns = 0.751879 MHz
* Slow Apple II cycle: 980 ns = 1.020408 MHz

* The time required for the refresh cycles reduces the effective processor speed for programs in RAM by 8 percent (there is a refresh cycle approximately every 3.5 µs, or 10 IIGS cycles).
* Programs in ROM run at the full 2.8 MHz speed.
* FPI to MEGA II synchronization consists of at least 0.350 µs (a single Mega II cycle), average 0.5µs, worst case 1µs.
* Memory refresh might take up 10% more time

* /M2SEL goes low when:
** Accesses to shadowed video writes
** Accesses to internal I/O (Except RW $C035, RW $C036, RW $C037, R $C02D, R $C068, R $C071 - $C07F) or expansion card slots
** Accesses to banks $E0 and $E1

Rules to read or write from slow memory:
* 8-bit access requires at least 2 more fast cycles
* 16-bit access requires at least 4 more fast cycles
* Synchronization can take up to 3 extra cycles
* RAM refresh delays can take

In short:
* Time referente is 14M
* Apple II: 64 instruction cycles of 14 clock cycles each, and one instruction cycle of 16 clock cycles
* Apple IIGS: one instruction cycle every 5 clock cycles. If memory is accessed, and we are on the refresh cycle, wait one cycle
* Apple IIGS: when in fast mode and accessing slow memory, wait for the next 1M clock cycle.

==Apple II Accelerators==
* TransWarp GS: 2.8, 5.6 MHz
* ZipGSX
* AE TransWarp: 1.79 MHz or 3.58 MHz, 256kB on board
* AE TransWarp II: 3.58 MHz or 7.16 MHz
* McT SpeeDemon: 3.58 MHz, 65C02, (first with caching)
* Saturn Accelerator II: 3.58 MHz, MOS6502, 64kB RAM on board
* Saturn Accelerator IIe: 3.58 MHz, 65C02, 64kB RAM on board
* ZIP Chip: 4 MHz, 8 MHz, caching (it also supports these factors: 1x, 2/3x, 3/4x, 4/5x, 5/6x, 1/2x, many more)
* Rocket Chip: 5 MHz, 10 MHz

* When simulating accelerators with cache: get an equivalent number of cycles per scanline, and execute that number of cycles. Ignore the IIGS rule of waiting for a scalene

==Apple IIGS Memory Map==
$0000	$01FF		Main/aux ZP
$0200	$03FF		Main/aux
$0400	$07FF		Main/aux - Shadowable
$0800	$0BFF		Main/aux - Shadowable
$0C00	$1FFF		Main/aux
$2000	$3FFF		Main/aux - Shadowable
$4000	$5FFF		Main/aux - Shadowable
$6000	$BFFF		Main/aux
$C000	..$C07F
$C080	..$C08F	Directly to slot
$C090	..$C09F
$C0A0	..$C0AF
$C0B0	..$C0BF
$C0C0	..$C0CF
$C0D0	..$C0DF
$C0E0	..$C0EF
$C0F0	..$C0FF
$C100	$C1FF	Directly to slot (slot should also update C800 space)
$C200	$C2FF
$C300	$C3FF
$C400	$C4FF
$C500	$C5FF
$C600	$C6FF
$C700	$C7FF
$C800	$CFFE	Directly to slot
$CFFF			Read slot 0
$D000	$DFFF	Main/aux LC, ROM
$E000	$FFFF	Main/aux LC, ROM

* C000-CFFF should be replicable in bank $00, $01, $E0, $E1
* Only bank 0 has main/aux selectivity
* Usually only bank 0 and 1 allow for shadowed memory

* First bank mapping: Map 0 for bank $00, map 1 for bank $01, map 2 for bank $02-$7f, map 3 for bank $E0, map 4 for bank $E1, map 5 for bank $E2-$FF
* Second zone mapping: 16 bit address to memory zone
