==Things to do these days==
* Implement OEEmulation device infos
* Implement hardware and template groups
* Implement addEDL
* Implement removeDevice
* Persistency of the main emulation window
* Implement the main emulation window list
* Implement main emulation window context menu
* Implement main emulation window mount/unmount
* Implement main emulation window reveal
* Implement main emulation window add EDL
* Implement main emulation window delete device
* Enable main emulation window system keyboard actions, when a device has a canvas
* Implement addCanvas and removeCanvas -> this should create a windowController and an OEOpenGLCanvas. The window controller should be added to the document, and the canvas returned.
* Implement frame communication to the canvas
* Implement canvas keyboard entry/mouse events
* Implement mouse and keyboard capture
* Implement canvas window persistency
* Implement [Document updateChangeCount]
* Implement OpenGL 2.0 shader code
* Implement the option to deactivate shaders
* Implement the inspector
* Add descriptions in template/hardware chooser
* Devise an interface to allow native OpenGL commands in emulations

==Future ideas==
* Debugging with JTAG
* TCP AT Modem emulation
* Debugger commands: run/step/break/readRegister/writeRegister/readMemory/writeMemory/addTrap/removeTrap/listTraps

==Apple-1 ideas==
* DA: Data Available
* RDA: Ready Data Accept
* ~W = ~RDA | ~(~RDA | RD6 | RD7)
* W = RDA & (RD6 | RD7)

==Apple-1 Cassette Interface ideas==
* ROM is visible at $C000-$C1FF
* $C000 to $C0FF generate a click
* $C080 to $C0FF puts A0 to 0, if a signal is detected
* A &= ~((A >> 7) & 1 | DET)
* O: if (DET) address &= ~1;

==Apple II ideas==
* There should be an MMU flag to inhibit Apple II memory space
* Apple II INH is $D000-$FFFF, Apple IIe $0000-$FFFF
* An interface is capable of modifying this flag, in order to inhibit the MMU
* Video obtains main and aux memory from MMU
* aux memory registers in the MMU
* MMU responds to $C001-$C00F, $C011-$C01F, $C050-$C057, $C080-$C08F.
* Apple II video is capable of delegating $C050-$C057
* The language card uses memory offset
* Game port allows delegations
* Video: Rev.0 has 4 colores with no color killer, rev. 1 has 6 with ck 
* Apple III resistors: 2k to SYNC, 2k to GND, 6.2k to X1 X2 X4 X8, 5.1k to NA NB
* Video chaining should be possible (for 80 column cards)
* Do this through video inhibition?



What follows is the compendium of old ideas (sorry about any spanish):

==oecli==
* Implement video connection with framebuffers and timer
* Implement Power/Pause/"Press CTRL-ALT to release mouse" overlays in OpenGL
* Implement inspector audio playback/recording (libsndfile for wav file access, secret rabbit code for sample rate conversion)
* How should sample rate conversion be applied to .wav resources?

==OpenEmulator Mac==
* Implement NSDocumentWindow toolbar with level-aware buttons
* Implement OpenGL display link
* When application looses focus, all full -screen windows should be de-zoomed
* Implement device settings. Replace minus with a configuration button. Show "Delete", "Edit Settings…", "Unmount disk image". Allowed settings types are select and checkbox. Retrieve and set settings with ioctl.
* Implement disk image drag and drop to document
* Implement disk image drag and drop to inspector
* Remember document window position and sizes
* Implement character palette (NSTextView?)
* Implement CPU Load

==libemulator==
* Implement event connection
* implement keyboard events to host (standard USB scancodes+UNICODE chars), option for CTRL-ALT mouse release
* Implement power-off, pause support (video overlay)
* Implement Apple II 
* Implement Apple II+
* Implement audio connection
* Implement mouse connection with support for capture/release
* Implement joystick connection
* Implement Paper Feed with PostScript generated in libemulator
* Implement tablet connection
* When mounting, there should be two messages: one for asking if a disk image is recognized, and another if it can be mounted.

==Later==
* Fix template chooser width problem, when scroll bars show and hide
* Fix template chooser problem when the first line of items is not selected

==Ideas para gráficos==
* Cuando escribo en la memoria de video, actualizo el video hasta donde está el CRT scan
* Cuando cambio el modo de video, actualizo el video hasta donde está el CRT scan (si es SHGR, guarda los bytes RGB)
* La actualización tiene que escribir sólo los bits a un buffer, no renderizarlo en NTSC (si es SHGR, guarda los bytes RGB)
* Debe haber algo que cambie la función de writeMemory en función del modo de video
* Renderizamos NTSC o RGB al final de un cuadro de video (si algo cambió).
* Tiene que haber eventos de tipo: CPU clock, Video scanline (byte 40), Video frame (linea 192), Video frame (linea 200 para SHGR)
* Debemos convertir el CPU clock a horizontal clock (para cuando hay aceleración)... ¿o no? directamente convierto uno en el otro
* Sería interesante emular los cambios de velocidad de un Apple IIGS cuando accede a memoria normal (2.5 MHz), ROM (2.8 MHz) y a la memoria de E0 y E1 (1.0 MHz).
* Idea: usar una latencia de 256 (187.5 Hz), 512 (93.75 Hz) muestras así el usuario no ve una diferencia audio <> imagen de más de 50 Hz.
* Idea: Implementar un shader para  hacer el procesamiento NTSC (!)
* Idea: Que la función de audio callback active un timer para imprimir el frame cuando corresponda

==Apple II Video Timing==
==Frames==
* viewFrame: The window frame
* screenFrame: The screen frame (in screen frame coordinates, 720x576 or 720x480)
* renderFrame: The frame where our data is rendered (in screen frame coordinates)
* bufferFrame: The frame where our data is obtained from (in video buffer coordinates) 

==Video Frames==
NTSC:
* Vertical blanking: 19 scanlines
* Visible: 243.5 scanlines
* Usually 240 scanlines are used

PAL:
* Vertical blanking: 25 scanlines
* Visible: 287.5 scanlines
* Usually 288 scanlines are used

==Video Scanlines==
NTSC:
* Color carrier  = 3.579545 MHz
* Horizontal frequency = (2 / 455) * Color carrier
* Horizontal period H = 1 / (3579545 * 2 / 455) = 63.556µs

* Front porch: 1.5µs
* Horizontal sync: 4.7µs
* Breezeway: 0.6µs
* Color burst: 2.50µs
* Back porch: 1.6µs

* Visible: 52.6556µs

PAL:
* Horziontal period: 64µs

* Front porch: 1.5µs
* Horizontal sync: 4.7µs
* Breezeway: 0.9µs
* Color burst: 2.25µs
* Back porch: 2.65µs

* Visible nominal: 52µs

==Visibility==
Usually 92% of total image

==VBL==
60 Hz	32 cycles before, 4 cycles VSYNC (33, 34, 35, 36), 34 later
50 Hz	72 cycles before, 4 cycles VSYNC (73, 74, 75, 76), 44 later

==HIRES==
Apple II:
	At the far left, the last video scanner dot is inserted
	At the far right, the last video scanner dot is always cut off
Apple IIe HIRES:
	At the far left, black is always inserted
	At the far right, the last video dot thing is always cut off

==Aspect ratio calculations==
Apple IIgs aspect ratio:
200mm x 150mm active video area
292mm diagonal (viewable): sqrt(x * x + x * x * 1.33 * 1.33) = x * sqrt(1 + 1.33^2)
233mm x 175mm
Video bandwidth: 1.5 dB at 6.5 MHz, 3 dB at 8 MHz

200 mm -> 532 pixels
233 mm -> 620 pixels

150 mm -> 400 pixels
175 mm -> 466 pixels

==Timing ideas==
OpenEmulator function prototypes:

AppleIIEventController
* onEvent()
{
	while (clockIndex < clockEnd)
	{
		if (clockIndex >= clockNextScanline)
		{
			clockNextScanline += 912;// 64*14 + 16;
			clockIndex += clockScanlineInc;
			scanlineCallback();
		}
		clockIndex += clockCycleInc;
		cpuCallback();
	}
}

For Apple II: clockCycleInc = 14, clockScanlineInc = 2
For Apple IIGS: clockCycleInc = 5, clockScanlineInc = 0
For Z80: clockCycleInc = 7, clockScanlineInc = 2

Optimize this, by having a function that computes the next event (be it a next scanline, or the end of this cycle

* selectCPU()
* setCPU(Component *)
* setCPUSpeed(double speed, bool isLongCycle)
* delay(double clockCount)
* getHorizontalClock()
* getHorizontalCount()
* getVerticalCount()
* getQ3()
* double getTime()

AudioController
* callback()
get(float **bufferIn, float **bufferOut, int *bufferSampleNum, int * bufferChannelNum, int *sampleRate)
* play(char *file, float volume, double time, bool isLooped)
* stop(double time);
* getTime()

VideoController

Hay 50 o 59,97 cuadros por segundo

Si uso 512 samples/buffer, hay 93.75 frames/seg
Si uso 1024, hay 46,875
Si uso 2048, hay 23,4375

Por cada audio buffer, renderizo N frames

Cada frame tiene estas propiedades:
* Tiempo (en el futuro)
* El puntero al framebuffer (en RGB)
* El tamaño del framebuffer, x e y
* Las proporciones del framebuffer

==Apple IIGS Timing==
| | | | | | | | | | | | | | | |
F         F         R         F
S                           S 

Master clock: 14 MHz (70ns)
Fast clock: 2.857 MHz
Slot clock: 1.020 MHz
1 out of every 10 fast clocks is refresh (thus the next is used up)

* Master clock: 70 ns = 14 MHz (!)
* Fast Apple IIGS cycle: 350 ns = 2.857142 MHz
* RAM Apple IIGS cycle: 700 ns = 1.428571 MHz
* Isolated Apple II cycle: 1330 ns = 0.751879 MHz
* Slow Apple II cycle: 980 ns = 1.020408 MHz

* The time required for the refresh cycles reduces the effective processor speed for programs in RAM by 8 percent (there is a refresh cycle approximately every 3.5 µs, or 10 IIGS cycles).
* Programs in ROM run at the full 2.8 MHz speed.
* FPI to MEGA II synchronization consists of at least 0.350 µs (a single Mega II cycle), average 0.5µs, worst case 1µs.
* Memory refresh might take up 10% more time

* /M2SEL goes low when:
** Accesses to shadowed video writes
** Accesses to internal I/O (Except RW $C035, RW $C036, RW $C037, R $C02D, R $C068, R $C071 - $C07F) or expansion card slots
** Accesses to banks $E0 and $E1

Rules to read or write from slow memory:
* 8-bit access requires at least 2 more fast cycles
* 16-bit access requires at least 4 more fast cycles
* Synchronization can take up to 3 extra cycles
* RAM refresh delays can take

Resumen:
* La referencia de tiempo son ciclos de 14M
* Para Apple II, hay un ciclo de reloj cada 14 ciclos de 14M, y uno de 16 cada 65-avo ciclo
* Para Apple IIGS, hay un ciclo de reloj cada 5 ciclos de 14M. Si intento leer la memoria, y el ciclo es uno de cada 10, espero otro ciclo
* Para Apple IIGS, cuando estoy en modo rápidos y accedo a la memoria lenta, espero hasta que pase el próximo ciclo de 1M. Cuando pasó, esper

==Apple II Accelerators==
* TransWarp GS, 2.8, 5.6 MHz
* ZipGSX
* AE TransWarp, 1.79 MHz or 3.58 MHz, 256kB on board
* AE TransWarp II, 3.58 MHz or 7.16 MHz
* McT SpeeDemon, 3.58 MHz, 65C02, primera con caching
* Saturn Accelerator II, 3.58 MHz, MOS6502, 64kB RAM on board
* Saturn Accelerator IIe, 3.58 MHz, 65C02, 64kB RAM on board
* ZIP Chip, 4 MHz, 8 MHz, caching (it also supports these factors: 1x, 2/3x, 3/4x, 4/5x, 5/6x, 1/2x, y muchos más
* Rocket Chip, 5 MHz, 10 MHz

Resumen: los aceleradores pueden proveer cualquier velocidad

* Cuando simulamos aceleradores con caché, hacemos lo siguiente: obtenemos un número equivalente de ciclos por scanline, y ejecutamos esta cantidad de ciclos. Ignoramos la regla del IIGS de esperar un scanline

==Apple-1 cursor timing==
Frequency 1.924 Hz
Duty cycle 66.6%
0.173 ms low (@ sign)
0.346 ms high (normal space)

==Signals and events==
SIGNAL_RESET_SET
SIGNAL_RESET_CLEAR
SIGNAL_IRQ_SET
SIGNAL_IRQ_CLEAR
SIGNAL_NMI_SET
SIGNAL_AN_SET						INDICATOR
SIGNAL_AN_CLEAR						INDICATOR
SIGNAL_VIDEO_SCANLINE
SIGNAL_VIDEO_FRAME

EVENT_KEYBOARD_SEND				BUFFER
EVENT_MEMORYZONE_SET				ZONE
EVENT_MEMORYHANDLER_SET			ADDRESSP
EVENT_VIDEO_TEXTBUFFER_GET		BUFFER
EVENT_VIDEO_SCANLINEADDRESS_GET	ADDRESSP
EVENT_VIDEO_VERTICALCOUNT_GET		ADDRESSP
EVENT_VIDEO_FLOATINGBUS_READ		ADDRESSP

==Memory Zones==
$0000	$01FF		Main/aux ZP
$0200	$03FF		Main/aux
$0400	$07FF		Main/aux - Shadowable
$0800	$0BFF		Main/aux - Shadowable
$0C00	$1FFF		Main/aux
$2000	$3FFF		Main/aux - Shadowable
$4000	$5FFF		Main/aux - Shadowable
$6000	$BFFF		Main/aux
$C000	..$C07F
$C080	..$C08F	Directly to slot
$C090	..$C09F
$C0A0	..$C0AF
$C0B0	..$C0BF
$C0C0	..$C0CF
$C0D0	..$C0DF
$C0E0	..$C0EF
$C0F0	..$C0FF
$C100	$C1FF	Directly to slot (slot should also update C800 space)
$C200	$C2FF
$C300	$C3FF
$C400	$C4FF
$C500	$C5FF
$C600	$C6FF
$C700	$C7FF
$C800	$CFFE	Directly to slot
$CFFF			Read slot 0
$D000	$DFFF	Main/aux LC, ROM
$E000	$FFFF	Main/aux LC, ROM

==Notes==
* C000-CFFF should be replicable in bank $00, $01, $E0, $E1
* Only bank 0 has main/aux selectivity
* Usually only bank 0 and 1 allow for shadowed memory

==Mapping idea==
* First bank mapping: Map 0 for bank $00, map 1 for bank $01, map 2 for bank $02-$7f, map 3 for bank $E0, map 4 for bank $E1, map 5 for bank $E2-$FF
* Second zone mapping: 16 bit address to memory zone

==Apple II==
* Replace second thread with a user SDL call. When buffers are not filled, fill with zeroes.
* Add support for SDL audio buffers that are not exactly a video frame in size
* Audio base class should tell (as a float) when a given event happens in sample time
* There should be some support for starting/stopping playback of audio streams. They should also be faded-in/out at start/end
* Implement CPU state machine with clock cycle accuracy
* MOS6502
* W65C02S
* Implement correct Apple II video mode changes
* Do text flash update only on the text part
* Debug "Apple II Split Screen Underline", so it works
* Implement NTSC rendering
* Implement resizing with SDL OpenGL
* See if one can check the windowed screen mode, and reopen SDL fullscreen with the same size as the windowed screen
* Implement Videx Videoterm
* Add mouse interface implicit redirection to paddles (when there are joysticks, this shouldn't be enabled)
* Fix edgyness of paddles when sketching in Blazing Paddles
* Disable text encoding menu when on Apple II
* Implement TransWarp (C074 switch)
* Test Saturn 128k RAM Board
* Trap not very often used soft switches (C000-C0FF) to check for unknown I/O access
* There has to be some provision for loading certain devices only once

==GUI==
* Replace artwork .xcf files with something that supports layers but isn't limited to GIMP
* Use wxWidgets. For now, wxWidgets should generate its own interface window and SDL a separate video window. Later we get the wxWidgets window ID, and tell SDL to use that one
* Persistency (when OpenEmulator is reopened, state should be preserved). When the computer is changed, the new computer should be reset (to avoid simultaneous usage of resources). Three kind of variables exist: initialized at program load, at machine restart, and at CPU reset
* Command line disk images should be mounted on drive 1 first, on drive 2 second, and so on
* Store profiles to ~/.openemulator/. On Windows, store to ~/Application Data/OpenEmulator
* Set default resources path to [app-path]/Resources
* Motherboard class should initialize slot and memory configuration. Each kind of Apple II should store its own slot and memory configuration.
* When re-mounting a mounted disk image, show an error
* Return error when a disk image can't be mounted because there's no appropriate drive
* In the configuration, every Apple II and every peripheral should have a description. Like saying in which slots and computers it should go, and other interactions...
* When starting a computer for the first time, there should be a dialogue requesting confirmation that you are allowed to use the ROM files
* The user has to be notified about the CTRL-ALT binding for releasing the mouse when the mouse is captured for the first time
* openFile should always open dialogs as sheets (there is a problem with the window id, try printing out to stdout)
* Implement preferences menu
* Implement print tape, A/V preferences, graphics tablet windows

==Apple IIe==
* Test Apple 3.5" Floppy Disk Drive Interface Card against all evil SmartPort scenarios
* Implement mouse card
* Fix RamWorks Basic and RamWorks III piggy-back memories (they don't work)

==Apple IIc==
* Implement mouse
* Implement ACIA's
* The external slots should not be configurable

==Disk==
* Fix 3.5" Disk Drive
* Add SmartPort isReady() call, to signal when a packet is finished processing
* Add format emulation to UniDisk 3.5" (with isReady())
* Disable eject on Apple 3.5" Disk Drive when isDriveEnabled is true 
* Implement GCR62Disk35 disk image writer
* Emulate 5.25" Disk Drive and 3.5" Disk Drive sounds
* Check if this is true: While resetting, the drives are turned off, but the 1s timer should not be disabled. When reset is over, drive 1 should still spin for the rest of the second
* Compare new disk emulation against AppleIIGo 153
* Improve NIB sync detection (by looking for regularly spaced sync data)
* Fix Wasteland, Alkemstone, Crusader in Europe, Decision in the Desert, Decisive Battles of the World, Earth Orbit Stations, Europe Ablaze, Hacker's Challenge, Halls of Montezuma, The Last Gladiator, LBSCharDisk, MacArthur's War
* Fix Sherlock Forest

==Apple IIGS==
* W65C816S
* Implement RGB non-linear NTSC converter
* Implement scanline interrupts
* ADB
* RTC
* DOC
* MMU: Fix IIGS language card emulation (ROM should also be mapped to banks E0 and E1).
* Implement disk motor slot detectors that slow down CPU
* Define an abstract SCC serial communications class. It should be common to all serial devices, being able to: list host serial devices, providing access, protecting against reopening a device
* Implement Apple IIGS

==Apple IIc plus==
* Implement IIc plus ZIP Chip

==Clones==
* Implement MicroprofessorIII
* Implement Laser128 and Laser128EX

==Optimization==
* Optimize MMU mapping calls (they are being repeated uselessly now)
* Try inlines (for speed)
* Fix SDL leaks
* Reduce code size: CPU emulator's (32k to 7k) and other speed sensitive  code segments
* Test speed: one executeInstructions() call per frame vs. many calls. Is there a large overhead?
* CPU: implement readMemory and writeMemory in CPU class. Does it bring any gains?
* CPU: optimize readMemory8 and writeMemory8 zero-page access in CPU class

==iPhone==
* Portrait view: (top) <= [Computer Name] (center) Monitor (bottom) Keyboard
* Landscape view: (top) <= [Computer name] (center) Monitor
* Swipes are the cursor keys
* Diagonal swipes are: control, tab, esc, delete
* OSD joystick control
* Disk view: (top) [Settings] Disk Images (top right) To Computer (screen) Disk Images, sorted by title (bottom) Recents, Disk Images
* When you tap on a disk image, you can choose the disk drive (it comes from below). If it is already mounted, you can eject it
* Settings: Computer, Memory expansion, self-centering joystick, text encoding, reset, restart

==Future==
* Slow down IIGS when IO is accessed
* Speed up IIGS when ROM is accessed
* Fix original Apple II HIRES left border issue, e.g. a write to $2027 should modify both pixel $2027 and pixel $2028
* Turn off SDL screen updates while minimizing
* Add a command line debugger
* Disk drag and drop to window. Reprogram NSWindow instance?
* Enable insert character from Edit menu
* Do something like Apple DOS FS
* NTSC color blurring between lines (like in Karateka) could be emulated

==Done==
* Implemented FileDiskImage class (for direct disk image I/O)
* Implemented Apple 3.5" Disk Drive eject on command signal falling edge
* Improved disk drive selection logic
* Fixed Apple 3.5" Disk Drive GCR
