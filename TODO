==To-Do==
* Implement shader persistance
* Implement power/pause/capture badge. Capture badge lasts 3 seconds and disappears in 1 second
* Implement the option to deactivate shaders
* Add support for scrolling canvas. Think about printing

* Fix device property scroller so it is updated even if the window is not active
* Add tooltips on property slider so the value can be seen
* If a default emulation can't be opened, should we start the template chooser instead? Or just improve the error message?
* Implement printing
* Implement hardware library
* Implement OEEmulation canAddEDL
* Implement OEEmulation addEDL
* Implement OEEmulation removeDevice
* Delete an emulation through Edit>Delete, or CMD+BACKSPACE
* Implement main emulation window add EDL
* Implement main emulation window remove device
* Support daisy chaining of devices, when a device has a port and connector of the same type (when adding or removing a device)
* Implement disk image file locking, if the disk image is writable (flock)

==NTSC phases==
227.5 cycles/line
113.75 halfcycles/line

Frame 1		Frame 2
0		180
 270		 90
180		0
 90		 270
0		180
 270		 90
180		0
 90		 270

==PAL Phases==
283.75 cycles/line
141.875 halfcycles/line

Frame 1		Frame 2		Frame 3		Frame 4
0		270		180		90
 315
270
 225
180
 135
90
 45

==Dot pitch==
13" monitor: dot pitch 0,28 mm
Horizontal dot pitch = 0,28 * 0,5 = 0,14
Horizontal tridot pitch = 0,28 *1,5 = 0,42mm
There are 10,4*25,4/0,42 = 628 horizontal elements

* None
* Shadow Mask
* Aperture Grille
* Slot Mask

==Future to-do's==
* Debugging with JTAG
* TCP AT Modem emulation
* Debugger commands: run/step/break/readRegister/writeRegister/readMemory/writeMemory/addTrap/removeTrap/listTraps

==Apple-1==
* DA: Data Available
* RDA: Ready Data Accept
* ~W = ~RDA | ~(~RDA | RD6 | RD7)
* W = RDA & (RD6 | RD7)

==Apple-1 Cassette Interface==
* ROM is visible at $C000-$C1FF
* $C000 to $C0FF generate a click
* $C080 to $C0FF puts A0 to 0, if a signal is detected
* A &= ~((A >> 7) & 1 | DET)
* O: if (DET) address &= ~1;

==Apple II==
* There should be an MMU flag to inhibit Apple II memory space
* Apple II INH is $D000-$FFFF, Apple IIe $0000-$FFFF, what should be Apple IIGS INH?
* An interface is capable of modifying this flag, in order to inhibit the MMU
* Video obtains main and aux memory from MMU
* aux memory registers in the MMU
* MMU responds to $C001-$C00F, $C011-$C01F, $C050-$C057, $C080-$C08F.
* Apple II video is capable of delegating $C050-$C057
* The language card uses memory offset
* Game port allows delegations
* Video: Rev.0 has 4 colores with no color killer, rev. 1 has 6 with ck 
* Video chaining should be possible (for 80 column cards)
* Do this through video inhibition?

==Apple III==
* Apple III video resistors: 2k to SYNC, 2k to GND, 6.2k to X1 X2 X4 X8, 5.1k to NA NB
* NTSC color weights:
** X1, X2, X4, X8 contribute 0.1555
** NA, NB contribute 0.189
** X1 contributes 0.058262
** X2 contributes 0.115242
** X4 contributes 0.243884
** X8 contributes 0.582612



What follows is the compendium of old ideas.

==OpenEmulator==
* When application looses focus, all fullscreen windows should be de-zoomed
* Implement CPU Load
* Fix template chooser width problem, when scroll bars show and hide
* Fix template chooser problem when the first line of items is not selected

==Apple-1 Video==
Cursor frequency 1.924 Hz
Cursor duty cycle 66.6%
0.173 ms low (@ sign)
0.346 ms high (normal space)

==Apple II==
* Check if this is true: While resetting, the drives are turned off, but the 1s timer should not be disabled. When reset is over, drive 1 should still spin for the rest of the second
* Improve NIB sync detection (by looking for regularly spaced sync data)
* Fix Wasteland, Alkemstone, Crusader in Europe, Decision in the Desert, Decisive Battles of the World, Earth Orbit Stations, Europe Ablaze, Hacker's Challenge, Halls of Montezuma, The Last Gladiator, LBSCharDisk, MacArthur's War
* Fix Sherlock Forest

==Apple II Video==
* When writing video memory, video is updated til current CRT position
* When video mode is changed, video is updated til CRT position
* There should be something to change writeMemory as a function of video mode
* Apple IIGS speed changes should be emulated, according to the kind of memory access: normal @ 2.5 MHz, ROM @ 2.8 MHz, E0 and E1 @ 1.0 MHz.
* Should vertical NTSC color blurring (for Karateka) be emulated?
* Idea: use audio buffer size of 256 (187.5 Hz) or 512 (93.75 Hz) samples, so user does not experience A/V desync.
* Apple IIGS aspect ratio:
200mm x 150mm active video area
292mm diagonal (viewable): sqrt(x * x + x * x * 1.33 * 1.33) = x * sqrt(1 + 1.33^2)
233mm x 175mm
Video bandwidth: 1.5 dB at 6.5 MHz, 3 dB at 8 MHz

200 mm -> 532 pixels
233 mm -> 620 pixels

150 mm -> 400 pixels
175 mm -> 466 pixels

* Apple II:
** At the far left, the last video scanner dot is inserted
** At the far right, the last video scanner dot is always cut off
* Apple IIe HIRES:
** At the far left, black is always inserted
** At the far right, the last video dot thing is always cut off

==Apple II Timing==
OpenEmulator function prototypes:

* onEvent()
{
	while (clockIndex < clockEnd)
	{
		if (clockIndex >= clockNextScanline)
		{
			clockNextScanline += 912;// 64*14 + 16;
			clockIndex += clockScanlineInc;
			scanlineCallback();
		}
		clockIndex += clockCycleInc;
		cpuCallback();
	}
}

For Apple II: clockCycleInc = 14, clockScanlineInc = 2
For Apple IIGS: clockCycleInc = 5, clockScanlineInc = 0
For Z80: clockCycleInc = 7, clockScanlineInc = 2

* selectCPU()
* setCPU(Component *)
* setCPUSpeed(double speed, bool isLongCycle)
* delay(double clockCount)
* getHorizontalClock()
* getHorizontalCount()
* getVerticalCount()
* getQ3()
* double getTime()

==Apple IIGS Timing==
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| 
F    R    F    F    F    F    F    F    F    F    F    R    F    F    F
S             S             S             S             S             S

Master clock: 14 MHz (70ns)
Fast clock: 2.857 MHz
Slot clock: 1.020 MHz
1 out of every 10 fast clocks is refresh (thus the next is used up)

* Master clock: 70 ns = 14 MHz (!)
* Fast Apple IIGS cycle: 350 ns = 2.857142 MHz
* RAM Apple IIGS cycle: 700 ns = 1.428571 MHz
* Isolated Apple II cycle: 1330 ns = 0.751879 MHz
* Slow Apple II cycle: 980 ns = 1.020408 MHz

* The time required for the refresh cycles reduces the effective processor speed for programs in RAM by 8 percent (there is a refresh cycle approximately every 3.5 탎, or 10 IIGS cycles).
* Programs in ROM run at the full 2.8 MHz speed.
* FPI to MEGA II synchronization consists of at least 0.350 탎 (a single Mega II cycle), average 0.5탎, worst case 1탎.
* Memory refresh might take up 10% more time

* /M2SEL goes low when:
** Accesses to shadowed video writes
** Accesses to internal I/O (Except RW $C035, RW $C036, RW $C037, R $C02D, R $C068, R $C071 - $C07F) or expansion card slots
** Accesses to banks $E0 and $E1

Rules to read or write from slow memory:
* 8-bit access requires at least 2 more fast cycles
* 16-bit access requires at least 4 more fast cycles
* Synchronization can take up to 3 extra cycles
* RAM refresh delays can take

In short:
* Time reference is 14M
* Apple II: 64 instruction cycles of 14 clock cycles each, and one instruction cycle of 16 clock cycles
* Apple IIGS: one instruction cycle every 5 clock cycles. If memory is accessed, and we are on the refresh cycle, wait one cycle
* Apple IIGS: when in fast mode and accessing slow memory, wait for the next 1M clock cycle.

==Apple II Accelerators==
* TransWarp GS: 2.8, 5.6 MHz
* ZipGSX
* AE TransWarp: 1.79 MHz or 3.58 MHz, 256kB on board
* AE TransWarp II: 3.58 MHz or 7.16 MHz
* McT SpeeDemon: 3.58 MHz, 65C02, (first with caching)
* Saturn Accelerator II: 3.58 MHz, MOS6502, 64kB RAM on board
* Saturn Accelerator IIe: 3.58 MHz, 65C02, 64kB RAM on board
* ZIP Chip: 4 MHz, 8 MHz, caching (it also supports these factors: 1x, 2/3x, 3/4x, 4/5x, 5/6x, 1/2x, many more)
* Rocket Chip: 5 MHz, 10 MHz

* When simulating accelerators with cache: get an equivalent number of cycles per scanline, and execute that number of cycles. Ignore the IIGS rule of waiting for a scalene

==Apple IIGS Memory Map==
$0000	$01FF		Main/aux ZP
$0200	$03FF		Main/aux
$0400	$07FF		Main/aux - Shadowable
$0800	$0BFF		Main/aux - Shadowable
$0C00	$1FFF		Main/aux
$2000	$3FFF		Main/aux - Shadowable
$4000	$5FFF		Main/aux - Shadowable
$6000	$BFFF		Main/aux
$C000	..$C07F
$C080	..$C08F	Directly to slot
$C090	..$C09F
$C0A0	..$C0AF
$C0B0	..$C0BF
$C0C0	..$C0CF
$C0D0	..$C0DF
$C0E0	..$C0EF
$C0F0	..$C0FF
$C100	$C1FF	Directly to slot (slot should also update C800 space)
$C200	$C2FF
$C300	$C3FF
$C400	$C4FF
$C500	$C5FF
$C600	$C6FF
$C700	$C7FF
$C800	$CFFE	Directly to slot
$CFFF			Read slot 0
$D000	$DFFF	Main/aux LC, ROM
$E000	$FFFF	Main/aux LC, ROM

* C000-CFFF should be replicable in bank $00, $01, $E0, $E1
* Only bank 0 has main/aux selectivity
* Usually only bank 0 and 1 allow for shadowed memory

* First bank mapping: Map 0 for bank $00, map 1 for bank $01, map 2 for bank $02-$7f, map 3 for bank $E0, map 4 for bank $E1, map 5 for bank $E2-$FF
* Second zone mapping: 16 bit address to memory zone
